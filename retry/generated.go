// THIS FILE IS AUTOGENERATED, DO NOT MODIFY IT DIRECTLY

package retry

import "time"

// Generated Code for Retry function with 8 input(s) and 8 output(s)
type func8to8[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error)
type retry8to8[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] struct {
	f           func8to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try8to8[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any](f func8to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) *retry8to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	return &retry8to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry8to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) ForTimes(times int) *retry8to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry8to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) WithBackoff(f BackoffTimingFunc) *retry8to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.backoff = f
	return retry
}
func (retry retry8to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, r7, err := retry.f(a0, a1, a2, a3, a4, a5, a6, a7)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, r7, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	var null7 TR7
	return null0, null1, null2, null3, null4, null5, null6, null7, err
}

// Generated Code for Retry function with 8 input(s) and 7 output(s)
type func8to7[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error)
type retry8to7[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] struct {
	f           func8to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try8to7[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any](f func8to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) *retry8to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	return &retry8to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry8to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) ForTimes(times int) *retry8to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry8to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) WithBackoff(f BackoffTimingFunc) *retry8to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.backoff = f
	return retry
}
func (retry retry8to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, err := retry.f(a0, a1, a2, a3, a4, a5, a6, a7)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	return null0, null1, null2, null3, null4, null5, null6, err
}

// Generated Code for Retry function with 8 input(s) and 6 output(s)
type func8to6[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error)
type retry8to6[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] struct {
	f           func8to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try8to6[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any](f func8to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5]) *retry8to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5] {
	return &retry8to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry8to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5]) ForTimes(times int) *retry8to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry8to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5]) WithBackoff(f BackoffTimingFunc) *retry8to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.backoff = f
	return retry
}
func (retry retry8to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4, TR5]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, err := retry.f(a0, a1, a2, a3, a4, a5, a6, a7)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	return null0, null1, null2, null3, null4, null5, err
}

// Generated Code for Retry function with 8 input(s) and 5 output(s)
type func8to5[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error)
type retry8to5[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] struct {
	f           func8to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try8to5[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any](f func8to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4]) *retry8to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4] {
	return &retry8to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry8to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4]) ForTimes(times int) *retry8to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry8to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4]) WithBackoff(f BackoffTimingFunc) *retry8to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4] {
	retry.backoff = f
	return retry
}
func (retry retry8to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3, TR4]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, err := retry.f(a0, a1, a2, a3, a4, a5, a6, a7)
		if err == nil {
			return r0, r1, r2, r3, r4, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	return null0, null1, null2, null3, null4, err
}

// Generated Code for Retry function with 8 input(s) and 4 output(s)
type func8to4[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any, TR3 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error)
type retry8to4[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any, TR3 any] struct {
	f           func8to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try8to4[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any, TR3 any](f func8to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3]) *retry8to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3] {
	return &retry8to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry8to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3]) ForTimes(times int) *retry8to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry8to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3]) WithBackoff(f BackoffTimingFunc) *retry8to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3] {
	retry.backoff = f
	return retry
}
func (retry retry8to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2, TR3]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, err := retry.f(a0, a1, a2, a3, a4, a5, a6, a7)
		if err == nil {
			return r0, r1, r2, r3, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	return null0, null1, null2, null3, err
}

// Generated Code for Retry function with 8 input(s) and 3 output(s)
type func8to3[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, r1 TR1, r2 TR2, err error)
type retry8to3[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any] struct {
	f           func8to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try8to3[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any, TR2 any](f func8to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2]) *retry8to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2] {
	return &retry8to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry8to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2]) ForTimes(times int) *retry8to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry8to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2]) WithBackoff(f BackoffTimingFunc) *retry8to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2] {
	retry.backoff = f
	return retry
}
func (retry retry8to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1, TR2]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, r1 TR1, r2 TR2, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, err := retry.f(a0, a1, a2, a3, a4, a5, a6, a7)
		if err == nil {
			return r0, r1, r2, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	return null0, null1, null2, err
}

// Generated Code for Retry function with 8 input(s) and 2 output(s)
type func8to2[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, r1 TR1, err error)
type retry8to2[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any] struct {
	f           func8to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try8to2[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any, TR1 any](f func8to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1]) *retry8to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1] {
	return &retry8to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry8to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1]) ForTimes(times int) *retry8to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry8to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1]) WithBackoff(f BackoffTimingFunc) *retry8to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1] {
	retry.backoff = f
	return retry
}
func (retry retry8to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0, TR1]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, r1 TR1, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, err := retry.f(a0, a1, a2, a3, a4, a5, a6, a7)
		if err == nil {
			return r0, r1, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	return null0, null1, err
}

// Generated Code for Retry function with 8 input(s) and 1 output(s)
type func8to1[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, err error)
type retry8to1[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any] struct {
	f           func8to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try8to1[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any, TR0 any](f func8to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0]) *retry8to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0] {
	return &retry8to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry8to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0]) ForTimes(times int) *retry8to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry8to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0]) WithBackoff(f BackoffTimingFunc) *retry8to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0] {
	retry.backoff = f
	return retry
}
func (retry retry8to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7, TR0]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (r0 TR0, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, err := retry.f(a0, a1, a2, a3, a4, a5, a6, a7)
		if err == nil {
			return r0, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	return null0, err
}

// Generated Code for Retry function with 8 input(s) and 0 output(s)
type func8to0[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (err error)
type retry8to0[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any] struct {
	f           func8to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try8to0[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TA7 any](f func8to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7]) *retry8to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7] {
	return &retry8to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry8to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7]) ForTimes(times int) *retry8to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry8to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7]) WithBackoff(f BackoffTimingFunc) *retry8to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7] {
	retry.backoff = f
	return retry
}
func (retry retry8to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TA7]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6, a7 TA7) (err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		err := retry.f(a0, a1, a2, a3, a4, a5, a6, a7)
		if err == nil {
			return nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	return err
}

// Generated Code for Retry function with 7 input(s) and 8 output(s)
type func7to8[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error)
type retry7to8[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] struct {
	f           func7to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try7to8[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any](f func7to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) *retry7to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	return &retry7to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry7to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) ForTimes(times int) *retry7to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry7to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) WithBackoff(f BackoffTimingFunc) *retry7to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.backoff = f
	return retry
}
func (retry retry7to8[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, r7, err := retry.f(a0, a1, a2, a3, a4, a5, a6)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, r7, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	var null7 TR7
	return null0, null1, null2, null3, null4, null5, null6, null7, err
}

// Generated Code for Retry function with 7 input(s) and 7 output(s)
type func7to7[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error)
type retry7to7[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] struct {
	f           func7to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try7to7[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any](f func7to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) *retry7to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	return &retry7to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry7to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) ForTimes(times int) *retry7to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry7to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) WithBackoff(f BackoffTimingFunc) *retry7to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.backoff = f
	return retry
}
func (retry retry7to7[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, err := retry.f(a0, a1, a2, a3, a4, a5, a6)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	return null0, null1, null2, null3, null4, null5, null6, err
}

// Generated Code for Retry function with 7 input(s) and 6 output(s)
type func7to6[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error)
type retry7to6[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] struct {
	f           func7to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try7to6[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any](f func7to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5]) *retry7to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5] {
	return &retry7to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry7to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5]) ForTimes(times int) *retry7to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry7to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5]) WithBackoff(f BackoffTimingFunc) *retry7to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.backoff = f
	return retry
}
func (retry retry7to6[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4, TR5]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, err := retry.f(a0, a1, a2, a3, a4, a5, a6)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	return null0, null1, null2, null3, null4, null5, err
}

// Generated Code for Retry function with 7 input(s) and 5 output(s)
type func7to5[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error)
type retry7to5[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] struct {
	f           func7to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try7to5[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any](f func7to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4]) *retry7to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4] {
	return &retry7to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry7to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4]) ForTimes(times int) *retry7to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry7to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4]) WithBackoff(f BackoffTimingFunc) *retry7to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4] {
	retry.backoff = f
	return retry
}
func (retry retry7to5[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3, TR4]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, err := retry.f(a0, a1, a2, a3, a4, a5, a6)
		if err == nil {
			return r0, r1, r2, r3, r4, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	return null0, null1, null2, null3, null4, err
}

// Generated Code for Retry function with 7 input(s) and 4 output(s)
type func7to4[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any, TR3 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error)
type retry7to4[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any, TR3 any] struct {
	f           func7to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try7to4[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any, TR3 any](f func7to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3]) *retry7to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3] {
	return &retry7to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry7to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3]) ForTimes(times int) *retry7to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry7to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3]) WithBackoff(f BackoffTimingFunc) *retry7to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3] {
	retry.backoff = f
	return retry
}
func (retry retry7to4[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2, TR3]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, err := retry.f(a0, a1, a2, a3, a4, a5, a6)
		if err == nil {
			return r0, r1, r2, r3, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	return null0, null1, null2, null3, err
}

// Generated Code for Retry function with 7 input(s) and 3 output(s)
type func7to3[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, r1 TR1, r2 TR2, err error)
type retry7to3[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any] struct {
	f           func7to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try7to3[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any, TR2 any](f func7to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2]) *retry7to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2] {
	return &retry7to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry7to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2]) ForTimes(times int) *retry7to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry7to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2]) WithBackoff(f BackoffTimingFunc) *retry7to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2] {
	retry.backoff = f
	return retry
}
func (retry retry7to3[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1, TR2]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, r1 TR1, r2 TR2, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, err := retry.f(a0, a1, a2, a3, a4, a5, a6)
		if err == nil {
			return r0, r1, r2, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	return null0, null1, null2, err
}

// Generated Code for Retry function with 7 input(s) and 2 output(s)
type func7to2[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, r1 TR1, err error)
type retry7to2[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any] struct {
	f           func7to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try7to2[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any, TR1 any](f func7to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1]) *retry7to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1] {
	return &retry7to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry7to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1]) ForTimes(times int) *retry7to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry7to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1]) WithBackoff(f BackoffTimingFunc) *retry7to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1] {
	retry.backoff = f
	return retry
}
func (retry retry7to2[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0, TR1]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, r1 TR1, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, err := retry.f(a0, a1, a2, a3, a4, a5, a6)
		if err == nil {
			return r0, r1, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	return null0, null1, err
}

// Generated Code for Retry function with 7 input(s) and 1 output(s)
type func7to1[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, err error)
type retry7to1[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any] struct {
	f           func7to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try7to1[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any, TR0 any](f func7to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0]) *retry7to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0] {
	return &retry7to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry7to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0]) ForTimes(times int) *retry7to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry7to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0]) WithBackoff(f BackoffTimingFunc) *retry7to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0] {
	retry.backoff = f
	return retry
}
func (retry retry7to1[TA0, TA1, TA2, TA3, TA4, TA5, TA6, TR0]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (r0 TR0, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, err := retry.f(a0, a1, a2, a3, a4, a5, a6)
		if err == nil {
			return r0, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	return null0, err
}

// Generated Code for Retry function with 7 input(s) and 0 output(s)
type func7to0[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (err error)
type retry7to0[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any] struct {
	f           func7to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try7to0[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TA6 any](f func7to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6]) *retry7to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6] {
	return &retry7to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry7to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6]) ForTimes(times int) *retry7to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry7to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6]) WithBackoff(f BackoffTimingFunc) *retry7to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6] {
	retry.backoff = f
	return retry
}
func (retry retry7to0[TA0, TA1, TA2, TA3, TA4, TA5, TA6]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5, a6 TA6) (err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		err := retry.f(a0, a1, a2, a3, a4, a5, a6)
		if err == nil {
			return nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	return err
}

// Generated Code for Retry function with 6 input(s) and 8 output(s)
type func6to8[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error)
type retry6to8[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] struct {
	f           func6to8[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try6to8[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any](f func6to8[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) *retry6to8[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	return &retry6to8[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry6to8[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) ForTimes(times int) *retry6to8[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry6to8[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) WithBackoff(f BackoffTimingFunc) *retry6to8[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.backoff = f
	return retry
}
func (retry retry6to8[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, r7, err := retry.f(a0, a1, a2, a3, a4, a5)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, r7, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	var null7 TR7
	return null0, null1, null2, null3, null4, null5, null6, null7, err
}

// Generated Code for Retry function with 6 input(s) and 7 output(s)
type func6to7[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error)
type retry6to7[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] struct {
	f           func6to7[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try6to7[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any](f func6to7[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) *retry6to7[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	return &retry6to7[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry6to7[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) ForTimes(times int) *retry6to7[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry6to7[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) WithBackoff(f BackoffTimingFunc) *retry6to7[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.backoff = f
	return retry
}
func (retry retry6to7[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, err := retry.f(a0, a1, a2, a3, a4, a5)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	return null0, null1, null2, null3, null4, null5, null6, err
}

// Generated Code for Retry function with 6 input(s) and 6 output(s)
type func6to6[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error)
type retry6to6[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] struct {
	f           func6to6[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try6to6[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any](f func6to6[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5]) *retry6to6[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5] {
	return &retry6to6[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry6to6[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5]) ForTimes(times int) *retry6to6[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry6to6[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5]) WithBackoff(f BackoffTimingFunc) *retry6to6[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.backoff = f
	return retry
}
func (retry retry6to6[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4, TR5]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, err := retry.f(a0, a1, a2, a3, a4, a5)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	return null0, null1, null2, null3, null4, null5, err
}

// Generated Code for Retry function with 6 input(s) and 5 output(s)
type func6to5[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error)
type retry6to5[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] struct {
	f           func6to5[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try6to5[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any](f func6to5[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4]) *retry6to5[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4] {
	return &retry6to5[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry6to5[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4]) ForTimes(times int) *retry6to5[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry6to5[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4]) WithBackoff(f BackoffTimingFunc) *retry6to5[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4] {
	retry.backoff = f
	return retry
}
func (retry retry6to5[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3, TR4]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, err := retry.f(a0, a1, a2, a3, a4, a5)
		if err == nil {
			return r0, r1, r2, r3, r4, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	return null0, null1, null2, null3, null4, err
}

// Generated Code for Retry function with 6 input(s) and 4 output(s)
type func6to4[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any, TR3 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error)
type retry6to4[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any, TR3 any] struct {
	f           func6to4[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try6to4[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any, TR3 any](f func6to4[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3]) *retry6to4[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3] {
	return &retry6to4[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry6to4[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3]) ForTimes(times int) *retry6to4[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry6to4[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3]) WithBackoff(f BackoffTimingFunc) *retry6to4[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3] {
	retry.backoff = f
	return retry
}
func (retry retry6to4[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2, TR3]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, err := retry.f(a0, a1, a2, a3, a4, a5)
		if err == nil {
			return r0, r1, r2, r3, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	return null0, null1, null2, null3, err
}

// Generated Code for Retry function with 6 input(s) and 3 output(s)
type func6to3[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, r1 TR1, r2 TR2, err error)
type retry6to3[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any] struct {
	f           func6to3[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try6to3[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any, TR2 any](f func6to3[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2]) *retry6to3[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2] {
	return &retry6to3[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry6to3[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2]) ForTimes(times int) *retry6to3[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry6to3[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2]) WithBackoff(f BackoffTimingFunc) *retry6to3[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2] {
	retry.backoff = f
	return retry
}
func (retry retry6to3[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1, TR2]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, r1 TR1, r2 TR2, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, err := retry.f(a0, a1, a2, a3, a4, a5)
		if err == nil {
			return r0, r1, r2, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	return null0, null1, null2, err
}

// Generated Code for Retry function with 6 input(s) and 2 output(s)
type func6to2[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, r1 TR1, err error)
type retry6to2[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any] struct {
	f           func6to2[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try6to2[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any, TR1 any](f func6to2[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1]) *retry6to2[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1] {
	return &retry6to2[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry6to2[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1]) ForTimes(times int) *retry6to2[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry6to2[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1]) WithBackoff(f BackoffTimingFunc) *retry6to2[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1] {
	retry.backoff = f
	return retry
}
func (retry retry6to2[TA0, TA1, TA2, TA3, TA4, TA5, TR0, TR1]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, r1 TR1, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, err := retry.f(a0, a1, a2, a3, a4, a5)
		if err == nil {
			return r0, r1, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	return null0, null1, err
}

// Generated Code for Retry function with 6 input(s) and 1 output(s)
type func6to1[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, err error)
type retry6to1[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any] struct {
	f           func6to1[TA0, TA1, TA2, TA3, TA4, TA5, TR0]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try6to1[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any, TR0 any](f func6to1[TA0, TA1, TA2, TA3, TA4, TA5, TR0]) *retry6to1[TA0, TA1, TA2, TA3, TA4, TA5, TR0] {
	return &retry6to1[TA0, TA1, TA2, TA3, TA4, TA5, TR0]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry6to1[TA0, TA1, TA2, TA3, TA4, TA5, TR0]) ForTimes(times int) *retry6to1[TA0, TA1, TA2, TA3, TA4, TA5, TR0] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry6to1[TA0, TA1, TA2, TA3, TA4, TA5, TR0]) WithBackoff(f BackoffTimingFunc) *retry6to1[TA0, TA1, TA2, TA3, TA4, TA5, TR0] {
	retry.backoff = f
	return retry
}
func (retry retry6to1[TA0, TA1, TA2, TA3, TA4, TA5, TR0]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (r0 TR0, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, err := retry.f(a0, a1, a2, a3, a4, a5)
		if err == nil {
			return r0, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	return null0, err
}

// Generated Code for Retry function with 6 input(s) and 0 output(s)
type func6to0[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (err error)
type retry6to0[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any] struct {
	f           func6to0[TA0, TA1, TA2, TA3, TA4, TA5]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try6to0[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TA5 any](f func6to0[TA0, TA1, TA2, TA3, TA4, TA5]) *retry6to0[TA0, TA1, TA2, TA3, TA4, TA5] {
	return &retry6to0[TA0, TA1, TA2, TA3, TA4, TA5]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry6to0[TA0, TA1, TA2, TA3, TA4, TA5]) ForTimes(times int) *retry6to0[TA0, TA1, TA2, TA3, TA4, TA5] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry6to0[TA0, TA1, TA2, TA3, TA4, TA5]) WithBackoff(f BackoffTimingFunc) *retry6to0[TA0, TA1, TA2, TA3, TA4, TA5] {
	retry.backoff = f
	return retry
}
func (retry retry6to0[TA0, TA1, TA2, TA3, TA4, TA5]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4, a5 TA5) (err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		err := retry.f(a0, a1, a2, a3, a4, a5)
		if err == nil {
			return nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	return err
}

// Generated Code for Retry function with 5 input(s) and 8 output(s)
type func5to8[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error)
type retry5to8[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] struct {
	f           func5to8[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try5to8[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any](f func5to8[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) *retry5to8[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	return &retry5to8[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry5to8[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) ForTimes(times int) *retry5to8[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry5to8[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) WithBackoff(f BackoffTimingFunc) *retry5to8[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.backoff = f
	return retry
}
func (retry retry5to8[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, r7, err := retry.f(a0, a1, a2, a3, a4)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, r7, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	var null7 TR7
	return null0, null1, null2, null3, null4, null5, null6, null7, err
}

// Generated Code for Retry function with 5 input(s) and 7 output(s)
type func5to7[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error)
type retry5to7[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] struct {
	f           func5to7[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try5to7[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any](f func5to7[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) *retry5to7[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	return &retry5to7[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry5to7[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) ForTimes(times int) *retry5to7[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry5to7[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) WithBackoff(f BackoffTimingFunc) *retry5to7[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.backoff = f
	return retry
}
func (retry retry5to7[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, err := retry.f(a0, a1, a2, a3, a4)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	return null0, null1, null2, null3, null4, null5, null6, err
}

// Generated Code for Retry function with 5 input(s) and 6 output(s)
type func5to6[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error)
type retry5to6[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] struct {
	f           func5to6[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try5to6[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any](f func5to6[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5]) *retry5to6[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5] {
	return &retry5to6[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry5to6[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5]) ForTimes(times int) *retry5to6[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry5to6[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5]) WithBackoff(f BackoffTimingFunc) *retry5to6[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.backoff = f
	return retry
}
func (retry retry5to6[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4, TR5]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, err := retry.f(a0, a1, a2, a3, a4)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	return null0, null1, null2, null3, null4, null5, err
}

// Generated Code for Retry function with 5 input(s) and 5 output(s)
type func5to5[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error)
type retry5to5[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] struct {
	f           func5to5[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try5to5[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any](f func5to5[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4]) *retry5to5[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4] {
	return &retry5to5[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry5to5[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4]) ForTimes(times int) *retry5to5[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry5to5[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4]) WithBackoff(f BackoffTimingFunc) *retry5to5[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4] {
	retry.backoff = f
	return retry
}
func (retry retry5to5[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3, TR4]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, err := retry.f(a0, a1, a2, a3, a4)
		if err == nil {
			return r0, r1, r2, r3, r4, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	return null0, null1, null2, null3, null4, err
}

// Generated Code for Retry function with 5 input(s) and 4 output(s)
type func5to4[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any, TR3 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error)
type retry5to4[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any, TR3 any] struct {
	f           func5to4[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try5to4[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any, TR3 any](f func5to4[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3]) *retry5to4[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3] {
	return &retry5to4[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry5to4[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3]) ForTimes(times int) *retry5to4[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry5to4[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3]) WithBackoff(f BackoffTimingFunc) *retry5to4[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3] {
	retry.backoff = f
	return retry
}
func (retry retry5to4[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2, TR3]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, err := retry.f(a0, a1, a2, a3, a4)
		if err == nil {
			return r0, r1, r2, r3, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	return null0, null1, null2, null3, err
}

// Generated Code for Retry function with 5 input(s) and 3 output(s)
type func5to3[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, r1 TR1, r2 TR2, err error)
type retry5to3[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any] struct {
	f           func5to3[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try5to3[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any, TR2 any](f func5to3[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2]) *retry5to3[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2] {
	return &retry5to3[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry5to3[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2]) ForTimes(times int) *retry5to3[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry5to3[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2]) WithBackoff(f BackoffTimingFunc) *retry5to3[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2] {
	retry.backoff = f
	return retry
}
func (retry retry5to3[TA0, TA1, TA2, TA3, TA4, TR0, TR1, TR2]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, r1 TR1, r2 TR2, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, err := retry.f(a0, a1, a2, a3, a4)
		if err == nil {
			return r0, r1, r2, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	return null0, null1, null2, err
}

// Generated Code for Retry function with 5 input(s) and 2 output(s)
type func5to2[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, r1 TR1, err error)
type retry5to2[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any] struct {
	f           func5to2[TA0, TA1, TA2, TA3, TA4, TR0, TR1]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try5to2[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any, TR1 any](f func5to2[TA0, TA1, TA2, TA3, TA4, TR0, TR1]) *retry5to2[TA0, TA1, TA2, TA3, TA4, TR0, TR1] {
	return &retry5to2[TA0, TA1, TA2, TA3, TA4, TR0, TR1]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry5to2[TA0, TA1, TA2, TA3, TA4, TR0, TR1]) ForTimes(times int) *retry5to2[TA0, TA1, TA2, TA3, TA4, TR0, TR1] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry5to2[TA0, TA1, TA2, TA3, TA4, TR0, TR1]) WithBackoff(f BackoffTimingFunc) *retry5to2[TA0, TA1, TA2, TA3, TA4, TR0, TR1] {
	retry.backoff = f
	return retry
}
func (retry retry5to2[TA0, TA1, TA2, TA3, TA4, TR0, TR1]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, r1 TR1, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, err := retry.f(a0, a1, a2, a3, a4)
		if err == nil {
			return r0, r1, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	return null0, null1, err
}

// Generated Code for Retry function with 5 input(s) and 1 output(s)
type func5to1[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, err error)
type retry5to1[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any] struct {
	f           func5to1[TA0, TA1, TA2, TA3, TA4, TR0]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try5to1[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any, TR0 any](f func5to1[TA0, TA1, TA2, TA3, TA4, TR0]) *retry5to1[TA0, TA1, TA2, TA3, TA4, TR0] {
	return &retry5to1[TA0, TA1, TA2, TA3, TA4, TR0]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry5to1[TA0, TA1, TA2, TA3, TA4, TR0]) ForTimes(times int) *retry5to1[TA0, TA1, TA2, TA3, TA4, TR0] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry5to1[TA0, TA1, TA2, TA3, TA4, TR0]) WithBackoff(f BackoffTimingFunc) *retry5to1[TA0, TA1, TA2, TA3, TA4, TR0] {
	retry.backoff = f
	return retry
}
func (retry retry5to1[TA0, TA1, TA2, TA3, TA4, TR0]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (r0 TR0, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, err := retry.f(a0, a1, a2, a3, a4)
		if err == nil {
			return r0, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	return null0, err
}

// Generated Code for Retry function with 5 input(s) and 0 output(s)
type func5to0[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (err error)
type retry5to0[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any] struct {
	f           func5to0[TA0, TA1, TA2, TA3, TA4]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try5to0[TA0 any, TA1 any, TA2 any, TA3 any, TA4 any](f func5to0[TA0, TA1, TA2, TA3, TA4]) *retry5to0[TA0, TA1, TA2, TA3, TA4] {
	return &retry5to0[TA0, TA1, TA2, TA3, TA4]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry5to0[TA0, TA1, TA2, TA3, TA4]) ForTimes(times int) *retry5to0[TA0, TA1, TA2, TA3, TA4] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry5to0[TA0, TA1, TA2, TA3, TA4]) WithBackoff(f BackoffTimingFunc) *retry5to0[TA0, TA1, TA2, TA3, TA4] {
	retry.backoff = f
	return retry
}
func (retry retry5to0[TA0, TA1, TA2, TA3, TA4]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3, a4 TA4) (err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		err := retry.f(a0, a1, a2, a3, a4)
		if err == nil {
			return nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	return err
}

// Generated Code for Retry function with 4 input(s) and 8 output(s)
type func4to8[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error)
type retry4to8[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] struct {
	f           func4to8[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try4to8[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any](f func4to8[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) *retry4to8[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	return &retry4to8[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry4to8[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) ForTimes(times int) *retry4to8[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry4to8[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) WithBackoff(f BackoffTimingFunc) *retry4to8[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.backoff = f
	return retry
}
func (retry retry4to8[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, r7, err := retry.f(a0, a1, a2, a3)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, r7, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	var null7 TR7
	return null0, null1, null2, null3, null4, null5, null6, null7, err
}

// Generated Code for Retry function with 4 input(s) and 7 output(s)
type func4to7[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error)
type retry4to7[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] struct {
	f           func4to7[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try4to7[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any](f func4to7[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) *retry4to7[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	return &retry4to7[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry4to7[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) ForTimes(times int) *retry4to7[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry4to7[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) WithBackoff(f BackoffTimingFunc) *retry4to7[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.backoff = f
	return retry
}
func (retry retry4to7[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, err := retry.f(a0, a1, a2, a3)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	return null0, null1, null2, null3, null4, null5, null6, err
}

// Generated Code for Retry function with 4 input(s) and 6 output(s)
type func4to6[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error)
type retry4to6[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] struct {
	f           func4to6[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try4to6[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any](f func4to6[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5]) *retry4to6[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5] {
	return &retry4to6[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry4to6[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5]) ForTimes(times int) *retry4to6[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry4to6[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5]) WithBackoff(f BackoffTimingFunc) *retry4to6[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.backoff = f
	return retry
}
func (retry retry4to6[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4, TR5]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, err := retry.f(a0, a1, a2, a3)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	return null0, null1, null2, null3, null4, null5, err
}

// Generated Code for Retry function with 4 input(s) and 5 output(s)
type func4to5[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error)
type retry4to5[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] struct {
	f           func4to5[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try4to5[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any](f func4to5[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4]) *retry4to5[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4] {
	return &retry4to5[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry4to5[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4]) ForTimes(times int) *retry4to5[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry4to5[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4]) WithBackoff(f BackoffTimingFunc) *retry4to5[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4] {
	retry.backoff = f
	return retry
}
func (retry retry4to5[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3, TR4]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, err := retry.f(a0, a1, a2, a3)
		if err == nil {
			return r0, r1, r2, r3, r4, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	return null0, null1, null2, null3, null4, err
}

// Generated Code for Retry function with 4 input(s) and 4 output(s)
type func4to4[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any, TR3 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error)
type retry4to4[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any, TR3 any] struct {
	f           func4to4[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try4to4[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any, TR3 any](f func4to4[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3]) *retry4to4[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3] {
	return &retry4to4[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry4to4[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3]) ForTimes(times int) *retry4to4[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry4to4[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3]) WithBackoff(f BackoffTimingFunc) *retry4to4[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3] {
	retry.backoff = f
	return retry
}
func (retry retry4to4[TA0, TA1, TA2, TA3, TR0, TR1, TR2, TR3]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, err := retry.f(a0, a1, a2, a3)
		if err == nil {
			return r0, r1, r2, r3, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	return null0, null1, null2, null3, err
}

// Generated Code for Retry function with 4 input(s) and 3 output(s)
type func4to3[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, r1 TR1, r2 TR2, err error)
type retry4to3[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any] struct {
	f           func4to3[TA0, TA1, TA2, TA3, TR0, TR1, TR2]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try4to3[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any, TR2 any](f func4to3[TA0, TA1, TA2, TA3, TR0, TR1, TR2]) *retry4to3[TA0, TA1, TA2, TA3, TR0, TR1, TR2] {
	return &retry4to3[TA0, TA1, TA2, TA3, TR0, TR1, TR2]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry4to3[TA0, TA1, TA2, TA3, TR0, TR1, TR2]) ForTimes(times int) *retry4to3[TA0, TA1, TA2, TA3, TR0, TR1, TR2] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry4to3[TA0, TA1, TA2, TA3, TR0, TR1, TR2]) WithBackoff(f BackoffTimingFunc) *retry4to3[TA0, TA1, TA2, TA3, TR0, TR1, TR2] {
	retry.backoff = f
	return retry
}
func (retry retry4to3[TA0, TA1, TA2, TA3, TR0, TR1, TR2]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, r1 TR1, r2 TR2, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, err := retry.f(a0, a1, a2, a3)
		if err == nil {
			return r0, r1, r2, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	return null0, null1, null2, err
}

// Generated Code for Retry function with 4 input(s) and 2 output(s)
type func4to2[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, r1 TR1, err error)
type retry4to2[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any] struct {
	f           func4to2[TA0, TA1, TA2, TA3, TR0, TR1]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try4to2[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any, TR1 any](f func4to2[TA0, TA1, TA2, TA3, TR0, TR1]) *retry4to2[TA0, TA1, TA2, TA3, TR0, TR1] {
	return &retry4to2[TA0, TA1, TA2, TA3, TR0, TR1]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry4to2[TA0, TA1, TA2, TA3, TR0, TR1]) ForTimes(times int) *retry4to2[TA0, TA1, TA2, TA3, TR0, TR1] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry4to2[TA0, TA1, TA2, TA3, TR0, TR1]) WithBackoff(f BackoffTimingFunc) *retry4to2[TA0, TA1, TA2, TA3, TR0, TR1] {
	retry.backoff = f
	return retry
}
func (retry retry4to2[TA0, TA1, TA2, TA3, TR0, TR1]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, r1 TR1, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, err := retry.f(a0, a1, a2, a3)
		if err == nil {
			return r0, r1, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	return null0, null1, err
}

// Generated Code for Retry function with 4 input(s) and 1 output(s)
type func4to1[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, err error)
type retry4to1[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any] struct {
	f           func4to1[TA0, TA1, TA2, TA3, TR0]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try4to1[TA0 any, TA1 any, TA2 any, TA3 any, TR0 any](f func4to1[TA0, TA1, TA2, TA3, TR0]) *retry4to1[TA0, TA1, TA2, TA3, TR0] {
	return &retry4to1[TA0, TA1, TA2, TA3, TR0]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry4to1[TA0, TA1, TA2, TA3, TR0]) ForTimes(times int) *retry4to1[TA0, TA1, TA2, TA3, TR0] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry4to1[TA0, TA1, TA2, TA3, TR0]) WithBackoff(f BackoffTimingFunc) *retry4to1[TA0, TA1, TA2, TA3, TR0] {
	retry.backoff = f
	return retry
}
func (retry retry4to1[TA0, TA1, TA2, TA3, TR0]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (r0 TR0, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, err := retry.f(a0, a1, a2, a3)
		if err == nil {
			return r0, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	return null0, err
}

// Generated Code for Retry function with 4 input(s) and 0 output(s)
type func4to0[TA0 any, TA1 any, TA2 any, TA3 any] func(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (err error)
type retry4to0[TA0 any, TA1 any, TA2 any, TA3 any] struct {
	f           func4to0[TA0, TA1, TA2, TA3]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try4to0[TA0 any, TA1 any, TA2 any, TA3 any](f func4to0[TA0, TA1, TA2, TA3]) *retry4to0[TA0, TA1, TA2, TA3] {
	return &retry4to0[TA0, TA1, TA2, TA3]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry4to0[TA0, TA1, TA2, TA3]) ForTimes(times int) *retry4to0[TA0, TA1, TA2, TA3] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry4to0[TA0, TA1, TA2, TA3]) WithBackoff(f BackoffTimingFunc) *retry4to0[TA0, TA1, TA2, TA3] {
	retry.backoff = f
	return retry
}
func (retry retry4to0[TA0, TA1, TA2, TA3]) Run(a0 TA0, a1 TA1, a2 TA2, a3 TA3) (err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		err := retry.f(a0, a1, a2, a3)
		if err == nil {
			return nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	return err
}

// Generated Code for Retry function with 3 input(s) and 8 output(s)
type func3to8[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] func(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error)
type retry3to8[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] struct {
	f           func3to8[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try3to8[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any](f func3to8[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) *retry3to8[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	return &retry3to8[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry3to8[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) ForTimes(times int) *retry3to8[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry3to8[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) WithBackoff(f BackoffTimingFunc) *retry3to8[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.backoff = f
	return retry
}
func (retry retry3to8[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) Run(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, r7, err := retry.f(a0, a1, a2)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, r7, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	var null7 TR7
	return null0, null1, null2, null3, null4, null5, null6, null7, err
}

// Generated Code for Retry function with 3 input(s) and 7 output(s)
type func3to7[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] func(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error)
type retry3to7[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] struct {
	f           func3to7[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try3to7[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any](f func3to7[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) *retry3to7[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	return &retry3to7[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry3to7[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) ForTimes(times int) *retry3to7[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry3to7[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) WithBackoff(f BackoffTimingFunc) *retry3to7[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.backoff = f
	return retry
}
func (retry retry3to7[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) Run(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, err := retry.f(a0, a1, a2)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	return null0, null1, null2, null3, null4, null5, null6, err
}

// Generated Code for Retry function with 3 input(s) and 6 output(s)
type func3to6[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] func(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error)
type retry3to6[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] struct {
	f           func3to6[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try3to6[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any](f func3to6[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5]) *retry3to6[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5] {
	return &retry3to6[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry3to6[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5]) ForTimes(times int) *retry3to6[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry3to6[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5]) WithBackoff(f BackoffTimingFunc) *retry3to6[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.backoff = f
	return retry
}
func (retry retry3to6[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4, TR5]) Run(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, err := retry.f(a0, a1, a2)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	return null0, null1, null2, null3, null4, null5, err
}

// Generated Code for Retry function with 3 input(s) and 5 output(s)
type func3to5[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] func(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error)
type retry3to5[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] struct {
	f           func3to5[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try3to5[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any](f func3to5[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4]) *retry3to5[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4] {
	return &retry3to5[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry3to5[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4]) ForTimes(times int) *retry3to5[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry3to5[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4]) WithBackoff(f BackoffTimingFunc) *retry3to5[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4] {
	retry.backoff = f
	return retry
}
func (retry retry3to5[TA0, TA1, TA2, TR0, TR1, TR2, TR3, TR4]) Run(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, err := retry.f(a0, a1, a2)
		if err == nil {
			return r0, r1, r2, r3, r4, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	return null0, null1, null2, null3, null4, err
}

// Generated Code for Retry function with 3 input(s) and 4 output(s)
type func3to4[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any, TR3 any] func(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error)
type retry3to4[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any, TR3 any] struct {
	f           func3to4[TA0, TA1, TA2, TR0, TR1, TR2, TR3]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try3to4[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any, TR3 any](f func3to4[TA0, TA1, TA2, TR0, TR1, TR2, TR3]) *retry3to4[TA0, TA1, TA2, TR0, TR1, TR2, TR3] {
	return &retry3to4[TA0, TA1, TA2, TR0, TR1, TR2, TR3]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry3to4[TA0, TA1, TA2, TR0, TR1, TR2, TR3]) ForTimes(times int) *retry3to4[TA0, TA1, TA2, TR0, TR1, TR2, TR3] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry3to4[TA0, TA1, TA2, TR0, TR1, TR2, TR3]) WithBackoff(f BackoffTimingFunc) *retry3to4[TA0, TA1, TA2, TR0, TR1, TR2, TR3] {
	retry.backoff = f
	return retry
}
func (retry retry3to4[TA0, TA1, TA2, TR0, TR1, TR2, TR3]) Run(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, err := retry.f(a0, a1, a2)
		if err == nil {
			return r0, r1, r2, r3, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	return null0, null1, null2, null3, err
}

// Generated Code for Retry function with 3 input(s) and 3 output(s)
type func3to3[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any] func(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, r1 TR1, r2 TR2, err error)
type retry3to3[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any] struct {
	f           func3to3[TA0, TA1, TA2, TR0, TR1, TR2]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try3to3[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any, TR2 any](f func3to3[TA0, TA1, TA2, TR0, TR1, TR2]) *retry3to3[TA0, TA1, TA2, TR0, TR1, TR2] {
	return &retry3to3[TA0, TA1, TA2, TR0, TR1, TR2]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry3to3[TA0, TA1, TA2, TR0, TR1, TR2]) ForTimes(times int) *retry3to3[TA0, TA1, TA2, TR0, TR1, TR2] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry3to3[TA0, TA1, TA2, TR0, TR1, TR2]) WithBackoff(f BackoffTimingFunc) *retry3to3[TA0, TA1, TA2, TR0, TR1, TR2] {
	retry.backoff = f
	return retry
}
func (retry retry3to3[TA0, TA1, TA2, TR0, TR1, TR2]) Run(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, r1 TR1, r2 TR2, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, err := retry.f(a0, a1, a2)
		if err == nil {
			return r0, r1, r2, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	return null0, null1, null2, err
}

// Generated Code for Retry function with 3 input(s) and 2 output(s)
type func3to2[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any] func(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, r1 TR1, err error)
type retry3to2[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any] struct {
	f           func3to2[TA0, TA1, TA2, TR0, TR1]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try3to2[TA0 any, TA1 any, TA2 any, TR0 any, TR1 any](f func3to2[TA0, TA1, TA2, TR0, TR1]) *retry3to2[TA0, TA1, TA2, TR0, TR1] {
	return &retry3to2[TA0, TA1, TA2, TR0, TR1]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry3to2[TA0, TA1, TA2, TR0, TR1]) ForTimes(times int) *retry3to2[TA0, TA1, TA2, TR0, TR1] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry3to2[TA0, TA1, TA2, TR0, TR1]) WithBackoff(f BackoffTimingFunc) *retry3to2[TA0, TA1, TA2, TR0, TR1] {
	retry.backoff = f
	return retry
}
func (retry retry3to2[TA0, TA1, TA2, TR0, TR1]) Run(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, r1 TR1, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, err := retry.f(a0, a1, a2)
		if err == nil {
			return r0, r1, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	return null0, null1, err
}

// Generated Code for Retry function with 3 input(s) and 1 output(s)
type func3to1[TA0 any, TA1 any, TA2 any, TR0 any] func(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, err error)
type retry3to1[TA0 any, TA1 any, TA2 any, TR0 any] struct {
	f           func3to1[TA0, TA1, TA2, TR0]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try3to1[TA0 any, TA1 any, TA2 any, TR0 any](f func3to1[TA0, TA1, TA2, TR0]) *retry3to1[TA0, TA1, TA2, TR0] {
	return &retry3to1[TA0, TA1, TA2, TR0]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry3to1[TA0, TA1, TA2, TR0]) ForTimes(times int) *retry3to1[TA0, TA1, TA2, TR0] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry3to1[TA0, TA1, TA2, TR0]) WithBackoff(f BackoffTimingFunc) *retry3to1[TA0, TA1, TA2, TR0] {
	retry.backoff = f
	return retry
}
func (retry retry3to1[TA0, TA1, TA2, TR0]) Run(a0 TA0, a1 TA1, a2 TA2) (r0 TR0, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, err := retry.f(a0, a1, a2)
		if err == nil {
			return r0, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	return null0, err
}

// Generated Code for Retry function with 3 input(s) and 0 output(s)
type func3to0[TA0 any, TA1 any, TA2 any] func(a0 TA0, a1 TA1, a2 TA2) (err error)
type retry3to0[TA0 any, TA1 any, TA2 any] struct {
	f           func3to0[TA0, TA1, TA2]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try3to0[TA0 any, TA1 any, TA2 any](f func3to0[TA0, TA1, TA2]) *retry3to0[TA0, TA1, TA2] {
	return &retry3to0[TA0, TA1, TA2]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry3to0[TA0, TA1, TA2]) ForTimes(times int) *retry3to0[TA0, TA1, TA2] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry3to0[TA0, TA1, TA2]) WithBackoff(f BackoffTimingFunc) *retry3to0[TA0, TA1, TA2] {
	retry.backoff = f
	return retry
}
func (retry retry3to0[TA0, TA1, TA2]) Run(a0 TA0, a1 TA1, a2 TA2) (err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		err := retry.f(a0, a1, a2)
		if err == nil {
			return nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	return err
}

// Generated Code for Retry function with 2 input(s) and 8 output(s)
type func2to8[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] func(a0 TA0, a1 TA1) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error)
type retry2to8[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] struct {
	f           func2to8[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try2to8[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any](f func2to8[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) *retry2to8[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	return &retry2to8[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry2to8[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) ForTimes(times int) *retry2to8[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry2to8[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) WithBackoff(f BackoffTimingFunc) *retry2to8[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.backoff = f
	return retry
}
func (retry retry2to8[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) Run(a0 TA0, a1 TA1) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, r7, err := retry.f(a0, a1)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, r7, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	var null7 TR7
	return null0, null1, null2, null3, null4, null5, null6, null7, err
}

// Generated Code for Retry function with 2 input(s) and 7 output(s)
type func2to7[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] func(a0 TA0, a1 TA1) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error)
type retry2to7[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] struct {
	f           func2to7[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try2to7[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any](f func2to7[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) *retry2to7[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	return &retry2to7[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry2to7[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) ForTimes(times int) *retry2to7[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry2to7[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) WithBackoff(f BackoffTimingFunc) *retry2to7[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.backoff = f
	return retry
}
func (retry retry2to7[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) Run(a0 TA0, a1 TA1) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, err := retry.f(a0, a1)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	return null0, null1, null2, null3, null4, null5, null6, err
}

// Generated Code for Retry function with 2 input(s) and 6 output(s)
type func2to6[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] func(a0 TA0, a1 TA1) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error)
type retry2to6[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] struct {
	f           func2to6[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try2to6[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any](f func2to6[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5]) *retry2to6[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5] {
	return &retry2to6[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry2to6[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5]) ForTimes(times int) *retry2to6[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry2to6[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5]) WithBackoff(f BackoffTimingFunc) *retry2to6[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.backoff = f
	return retry
}
func (retry retry2to6[TA0, TA1, TR0, TR1, TR2, TR3, TR4, TR5]) Run(a0 TA0, a1 TA1) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, err := retry.f(a0, a1)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	return null0, null1, null2, null3, null4, null5, err
}

// Generated Code for Retry function with 2 input(s) and 5 output(s)
type func2to5[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] func(a0 TA0, a1 TA1) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error)
type retry2to5[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] struct {
	f           func2to5[TA0, TA1, TR0, TR1, TR2, TR3, TR4]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try2to5[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any](f func2to5[TA0, TA1, TR0, TR1, TR2, TR3, TR4]) *retry2to5[TA0, TA1, TR0, TR1, TR2, TR3, TR4] {
	return &retry2to5[TA0, TA1, TR0, TR1, TR2, TR3, TR4]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry2to5[TA0, TA1, TR0, TR1, TR2, TR3, TR4]) ForTimes(times int) *retry2to5[TA0, TA1, TR0, TR1, TR2, TR3, TR4] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry2to5[TA0, TA1, TR0, TR1, TR2, TR3, TR4]) WithBackoff(f BackoffTimingFunc) *retry2to5[TA0, TA1, TR0, TR1, TR2, TR3, TR4] {
	retry.backoff = f
	return retry
}
func (retry retry2to5[TA0, TA1, TR0, TR1, TR2, TR3, TR4]) Run(a0 TA0, a1 TA1) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, err := retry.f(a0, a1)
		if err == nil {
			return r0, r1, r2, r3, r4, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	return null0, null1, null2, null3, null4, err
}

// Generated Code for Retry function with 2 input(s) and 4 output(s)
type func2to4[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any, TR3 any] func(a0 TA0, a1 TA1) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error)
type retry2to4[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any, TR3 any] struct {
	f           func2to4[TA0, TA1, TR0, TR1, TR2, TR3]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try2to4[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any, TR3 any](f func2to4[TA0, TA1, TR0, TR1, TR2, TR3]) *retry2to4[TA0, TA1, TR0, TR1, TR2, TR3] {
	return &retry2to4[TA0, TA1, TR0, TR1, TR2, TR3]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry2to4[TA0, TA1, TR0, TR1, TR2, TR3]) ForTimes(times int) *retry2to4[TA0, TA1, TR0, TR1, TR2, TR3] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry2to4[TA0, TA1, TR0, TR1, TR2, TR3]) WithBackoff(f BackoffTimingFunc) *retry2to4[TA0, TA1, TR0, TR1, TR2, TR3] {
	retry.backoff = f
	return retry
}
func (retry retry2to4[TA0, TA1, TR0, TR1, TR2, TR3]) Run(a0 TA0, a1 TA1) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, err := retry.f(a0, a1)
		if err == nil {
			return r0, r1, r2, r3, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	return null0, null1, null2, null3, err
}

// Generated Code for Retry function with 2 input(s) and 3 output(s)
type func2to3[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any] func(a0 TA0, a1 TA1) (r0 TR0, r1 TR1, r2 TR2, err error)
type retry2to3[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any] struct {
	f           func2to3[TA0, TA1, TR0, TR1, TR2]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try2to3[TA0 any, TA1 any, TR0 any, TR1 any, TR2 any](f func2to3[TA0, TA1, TR0, TR1, TR2]) *retry2to3[TA0, TA1, TR0, TR1, TR2] {
	return &retry2to3[TA0, TA1, TR0, TR1, TR2]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry2to3[TA0, TA1, TR0, TR1, TR2]) ForTimes(times int) *retry2to3[TA0, TA1, TR0, TR1, TR2] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry2to3[TA0, TA1, TR0, TR1, TR2]) WithBackoff(f BackoffTimingFunc) *retry2to3[TA0, TA1, TR0, TR1, TR2] {
	retry.backoff = f
	return retry
}
func (retry retry2to3[TA0, TA1, TR0, TR1, TR2]) Run(a0 TA0, a1 TA1) (r0 TR0, r1 TR1, r2 TR2, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, err := retry.f(a0, a1)
		if err == nil {
			return r0, r1, r2, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	return null0, null1, null2, err
}

// Generated Code for Retry function with 2 input(s) and 2 output(s)
type func2to2[TA0 any, TA1 any, TR0 any, TR1 any] func(a0 TA0, a1 TA1) (r0 TR0, r1 TR1, err error)
type retry2to2[TA0 any, TA1 any, TR0 any, TR1 any] struct {
	f           func2to2[TA0, TA1, TR0, TR1]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try2to2[TA0 any, TA1 any, TR0 any, TR1 any](f func2to2[TA0, TA1, TR0, TR1]) *retry2to2[TA0, TA1, TR0, TR1] {
	return &retry2to2[TA0, TA1, TR0, TR1]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry2to2[TA0, TA1, TR0, TR1]) ForTimes(times int) *retry2to2[TA0, TA1, TR0, TR1] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry2to2[TA0, TA1, TR0, TR1]) WithBackoff(f BackoffTimingFunc) *retry2to2[TA0, TA1, TR0, TR1] {
	retry.backoff = f
	return retry
}
func (retry retry2to2[TA0, TA1, TR0, TR1]) Run(a0 TA0, a1 TA1) (r0 TR0, r1 TR1, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, err := retry.f(a0, a1)
		if err == nil {
			return r0, r1, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	return null0, null1, err
}

// Generated Code for Retry function with 2 input(s) and 1 output(s)
type func2to1[TA0 any, TA1 any, TR0 any] func(a0 TA0, a1 TA1) (r0 TR0, err error)
type retry2to1[TA0 any, TA1 any, TR0 any] struct {
	f           func2to1[TA0, TA1, TR0]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try2to1[TA0 any, TA1 any, TR0 any](f func2to1[TA0, TA1, TR0]) *retry2to1[TA0, TA1, TR0] {
	return &retry2to1[TA0, TA1, TR0]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry2to1[TA0, TA1, TR0]) ForTimes(times int) *retry2to1[TA0, TA1, TR0] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry2to1[TA0, TA1, TR0]) WithBackoff(f BackoffTimingFunc) *retry2to1[TA0, TA1, TR0] {
	retry.backoff = f
	return retry
}
func (retry retry2to1[TA0, TA1, TR0]) Run(a0 TA0, a1 TA1) (r0 TR0, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, err := retry.f(a0, a1)
		if err == nil {
			return r0, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	return null0, err
}

// Generated Code for Retry function with 2 input(s) and 0 output(s)
type func2to0[TA0 any, TA1 any] func(a0 TA0, a1 TA1) (err error)
type retry2to0[TA0 any, TA1 any] struct {
	f           func2to0[TA0, TA1]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try2to0[TA0 any, TA1 any](f func2to0[TA0, TA1]) *retry2to0[TA0, TA1] {
	return &retry2to0[TA0, TA1]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry2to0[TA0, TA1]) ForTimes(times int) *retry2to0[TA0, TA1] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry2to0[TA0, TA1]) WithBackoff(f BackoffTimingFunc) *retry2to0[TA0, TA1] {
	retry.backoff = f
	return retry
}
func (retry retry2to0[TA0, TA1]) Run(a0 TA0, a1 TA1) (err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		err := retry.f(a0, a1)
		if err == nil {
			return nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	return err
}

// Generated Code for Retry function with 1 input(s) and 8 output(s)
type func1to8[TA0 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] func(a0 TA0) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error)
type retry1to8[TA0 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] struct {
	f           func1to8[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try1to8[TA0 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any](f func1to8[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) *retry1to8[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	return &retry1to8[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry1to8[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) ForTimes(times int) *retry1to8[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry1to8[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) WithBackoff(f BackoffTimingFunc) *retry1to8[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.backoff = f
	return retry
}
func (retry retry1to8[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) Run(a0 TA0) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, r7, err := retry.f(a0)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, r7, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	var null7 TR7
	return null0, null1, null2, null3, null4, null5, null6, null7, err
}

// Generated Code for Retry function with 1 input(s) and 7 output(s)
type func1to7[TA0 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] func(a0 TA0) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error)
type retry1to7[TA0 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] struct {
	f           func1to7[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try1to7[TA0 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any](f func1to7[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) *retry1to7[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	return &retry1to7[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry1to7[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) ForTimes(times int) *retry1to7[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry1to7[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) WithBackoff(f BackoffTimingFunc) *retry1to7[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.backoff = f
	return retry
}
func (retry retry1to7[TA0, TR0, TR1, TR2, TR3, TR4, TR5, TR6]) Run(a0 TA0) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, err := retry.f(a0)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	return null0, null1, null2, null3, null4, null5, null6, err
}

// Generated Code for Retry function with 1 input(s) and 6 output(s)
type func1to6[TA0 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] func(a0 TA0) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error)
type retry1to6[TA0 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] struct {
	f           func1to6[TA0, TR0, TR1, TR2, TR3, TR4, TR5]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try1to6[TA0 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any](f func1to6[TA0, TR0, TR1, TR2, TR3, TR4, TR5]) *retry1to6[TA0, TR0, TR1, TR2, TR3, TR4, TR5] {
	return &retry1to6[TA0, TR0, TR1, TR2, TR3, TR4, TR5]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry1to6[TA0, TR0, TR1, TR2, TR3, TR4, TR5]) ForTimes(times int) *retry1to6[TA0, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry1to6[TA0, TR0, TR1, TR2, TR3, TR4, TR5]) WithBackoff(f BackoffTimingFunc) *retry1to6[TA0, TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.backoff = f
	return retry
}
func (retry retry1to6[TA0, TR0, TR1, TR2, TR3, TR4, TR5]) Run(a0 TA0) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, err := retry.f(a0)
		if err == nil {
			return r0, r1, r2, r3, r4, r5, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	return null0, null1, null2, null3, null4, null5, err
}

// Generated Code for Retry function with 1 input(s) and 5 output(s)
type func1to5[TA0 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] func(a0 TA0) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error)
type retry1to5[TA0 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] struct {
	f           func1to5[TA0, TR0, TR1, TR2, TR3, TR4]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try1to5[TA0 any, TR0 any, TR1 any, TR2 any, TR3 any, TR4 any](f func1to5[TA0, TR0, TR1, TR2, TR3, TR4]) *retry1to5[TA0, TR0, TR1, TR2, TR3, TR4] {
	return &retry1to5[TA0, TR0, TR1, TR2, TR3, TR4]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry1to5[TA0, TR0, TR1, TR2, TR3, TR4]) ForTimes(times int) *retry1to5[TA0, TR0, TR1, TR2, TR3, TR4] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry1to5[TA0, TR0, TR1, TR2, TR3, TR4]) WithBackoff(f BackoffTimingFunc) *retry1to5[TA0, TR0, TR1, TR2, TR3, TR4] {
	retry.backoff = f
	return retry
}
func (retry retry1to5[TA0, TR0, TR1, TR2, TR3, TR4]) Run(a0 TA0) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, err := retry.f(a0)
		if err == nil {
			return r0, r1, r2, r3, r4, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	return null0, null1, null2, null3, null4, err
}

// Generated Code for Retry function with 1 input(s) and 4 output(s)
type func1to4[TA0 any, TR0 any, TR1 any, TR2 any, TR3 any] func(a0 TA0) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error)
type retry1to4[TA0 any, TR0 any, TR1 any, TR2 any, TR3 any] struct {
	f           func1to4[TA0, TR0, TR1, TR2, TR3]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try1to4[TA0 any, TR0 any, TR1 any, TR2 any, TR3 any](f func1to4[TA0, TR0, TR1, TR2, TR3]) *retry1to4[TA0, TR0, TR1, TR2, TR3] {
	return &retry1to4[TA0, TR0, TR1, TR2, TR3]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry1to4[TA0, TR0, TR1, TR2, TR3]) ForTimes(times int) *retry1to4[TA0, TR0, TR1, TR2, TR3] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry1to4[TA0, TR0, TR1, TR2, TR3]) WithBackoff(f BackoffTimingFunc) *retry1to4[TA0, TR0, TR1, TR2, TR3] {
	retry.backoff = f
	return retry
}
func (retry retry1to4[TA0, TR0, TR1, TR2, TR3]) Run(a0 TA0) (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, err := retry.f(a0)
		if err == nil {
			return r0, r1, r2, r3, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	return null0, null1, null2, null3, err
}

// Generated Code for Retry function with 1 input(s) and 3 output(s)
type func1to3[TA0 any, TR0 any, TR1 any, TR2 any] func(a0 TA0) (r0 TR0, r1 TR1, r2 TR2, err error)
type retry1to3[TA0 any, TR0 any, TR1 any, TR2 any] struct {
	f           func1to3[TA0, TR0, TR1, TR2]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try1to3[TA0 any, TR0 any, TR1 any, TR2 any](f func1to3[TA0, TR0, TR1, TR2]) *retry1to3[TA0, TR0, TR1, TR2] {
	return &retry1to3[TA0, TR0, TR1, TR2]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry1to3[TA0, TR0, TR1, TR2]) ForTimes(times int) *retry1to3[TA0, TR0, TR1, TR2] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry1to3[TA0, TR0, TR1, TR2]) WithBackoff(f BackoffTimingFunc) *retry1to3[TA0, TR0, TR1, TR2] {
	retry.backoff = f
	return retry
}
func (retry retry1to3[TA0, TR0, TR1, TR2]) Run(a0 TA0) (r0 TR0, r1 TR1, r2 TR2, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, err := retry.f(a0)
		if err == nil {
			return r0, r1, r2, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	return null0, null1, null2, err
}

// Generated Code for Retry function with 1 input(s) and 2 output(s)
type func1to2[TA0 any, TR0 any, TR1 any] func(a0 TA0) (r0 TR0, r1 TR1, err error)
type retry1to2[TA0 any, TR0 any, TR1 any] struct {
	f           func1to2[TA0, TR0, TR1]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try1to2[TA0 any, TR0 any, TR1 any](f func1to2[TA0, TR0, TR1]) *retry1to2[TA0, TR0, TR1] {
	return &retry1to2[TA0, TR0, TR1]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry1to2[TA0, TR0, TR1]) ForTimes(times int) *retry1to2[TA0, TR0, TR1] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry1to2[TA0, TR0, TR1]) WithBackoff(f BackoffTimingFunc) *retry1to2[TA0, TR0, TR1] {
	retry.backoff = f
	return retry
}
func (retry retry1to2[TA0, TR0, TR1]) Run(a0 TA0) (r0 TR0, r1 TR1, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, err := retry.f(a0)
		if err == nil {
			return r0, r1, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	return null0, null1, err
}

// Generated Code for Retry function with 1 input(s) and 1 output(s)
type func1to1[TA0 any, TR0 any] func(a0 TA0) (r0 TR0, err error)
type retry1to1[TA0 any, TR0 any] struct {
	f           func1to1[TA0, TR0]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try1to1[TA0 any, TR0 any](f func1to1[TA0, TR0]) *retry1to1[TA0, TR0] {
	return &retry1to1[TA0, TR0]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry1to1[TA0, TR0]) ForTimes(times int) *retry1to1[TA0, TR0] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry1to1[TA0, TR0]) WithBackoff(f BackoffTimingFunc) *retry1to1[TA0, TR0] {
	retry.backoff = f
	return retry
}
func (retry retry1to1[TA0, TR0]) Run(a0 TA0) (r0 TR0, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, err := retry.f(a0)
		if err == nil {
			return r0, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	return null0, err
}

// Generated Code for Retry function with 1 input(s) and 0 output(s)
type func1to0[TA0 any] func(a0 TA0) (err error)
type retry1to0[TA0 any] struct {
	f           func1to0[TA0]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try1to0[TA0 any](f func1to0[TA0]) *retry1to0[TA0] {
	return &retry1to0[TA0]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry1to0[TA0]) ForTimes(times int) *retry1to0[TA0] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry1to0[TA0]) WithBackoff(f BackoffTimingFunc) *retry1to0[TA0] {
	retry.backoff = f
	return retry
}
func (retry retry1to0[TA0]) Run(a0 TA0) (err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		err := retry.f(a0)
		if err == nil {
			return nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	return err
}

// Generated Code for Retry function with 0 input(s) and 8 output(s)
type func0to8[TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] func() (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error)
type retry0to8[TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any] struct {
	f           func0to8[TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try0to8[TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any, TR7 any](f func0to8[TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) *retry0to8[TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	return &retry0to8[TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry0to8[TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) ForTimes(times int) *retry0to8[TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry0to8[TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) WithBackoff(f BackoffTimingFunc) *retry0to8[TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7] {
	retry.backoff = f
	return retry
}
func (retry retry0to8[TR0, TR1, TR2, TR3, TR4, TR5, TR6, TR7]) Run() (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, r7 TR7, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, r7, err := retry.f()
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, r7, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	var null7 TR7
	return null0, null1, null2, null3, null4, null5, null6, null7, err
}

// Generated Code for Retry function with 0 input(s) and 7 output(s)
type func0to7[TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] func() (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error)
type retry0to7[TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any] struct {
	f           func0to7[TR0, TR1, TR2, TR3, TR4, TR5, TR6]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try0to7[TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any, TR6 any](f func0to7[TR0, TR1, TR2, TR3, TR4, TR5, TR6]) *retry0to7[TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	return &retry0to7[TR0, TR1, TR2, TR3, TR4, TR5, TR6]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry0to7[TR0, TR1, TR2, TR3, TR4, TR5, TR6]) ForTimes(times int) *retry0to7[TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry0to7[TR0, TR1, TR2, TR3, TR4, TR5, TR6]) WithBackoff(f BackoffTimingFunc) *retry0to7[TR0, TR1, TR2, TR3, TR4, TR5, TR6] {
	retry.backoff = f
	return retry
}
func (retry retry0to7[TR0, TR1, TR2, TR3, TR4, TR5, TR6]) Run() (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, r6 TR6, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, r6, err := retry.f()
		if err == nil {
			return r0, r1, r2, r3, r4, r5, r6, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	var null6 TR6
	return null0, null1, null2, null3, null4, null5, null6, err
}

// Generated Code for Retry function with 0 input(s) and 6 output(s)
type func0to6[TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] func() (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error)
type retry0to6[TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any] struct {
	f           func0to6[TR0, TR1, TR2, TR3, TR4, TR5]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try0to6[TR0 any, TR1 any, TR2 any, TR3 any, TR4 any, TR5 any](f func0to6[TR0, TR1, TR2, TR3, TR4, TR5]) *retry0to6[TR0, TR1, TR2, TR3, TR4, TR5] {
	return &retry0to6[TR0, TR1, TR2, TR3, TR4, TR5]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry0to6[TR0, TR1, TR2, TR3, TR4, TR5]) ForTimes(times int) *retry0to6[TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry0to6[TR0, TR1, TR2, TR3, TR4, TR5]) WithBackoff(f BackoffTimingFunc) *retry0to6[TR0, TR1, TR2, TR3, TR4, TR5] {
	retry.backoff = f
	return retry
}
func (retry retry0to6[TR0, TR1, TR2, TR3, TR4, TR5]) Run() (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, r5 TR5, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, r5, err := retry.f()
		if err == nil {
			return r0, r1, r2, r3, r4, r5, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	var null5 TR5
	return null0, null1, null2, null3, null4, null5, err
}

// Generated Code for Retry function with 0 input(s) and 5 output(s)
type func0to5[TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] func() (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error)
type retry0to5[TR0 any, TR1 any, TR2 any, TR3 any, TR4 any] struct {
	f           func0to5[TR0, TR1, TR2, TR3, TR4]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try0to5[TR0 any, TR1 any, TR2 any, TR3 any, TR4 any](f func0to5[TR0, TR1, TR2, TR3, TR4]) *retry0to5[TR0, TR1, TR2, TR3, TR4] {
	return &retry0to5[TR0, TR1, TR2, TR3, TR4]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry0to5[TR0, TR1, TR2, TR3, TR4]) ForTimes(times int) *retry0to5[TR0, TR1, TR2, TR3, TR4] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry0to5[TR0, TR1, TR2, TR3, TR4]) WithBackoff(f BackoffTimingFunc) *retry0to5[TR0, TR1, TR2, TR3, TR4] {
	retry.backoff = f
	return retry
}
func (retry retry0to5[TR0, TR1, TR2, TR3, TR4]) Run() (r0 TR0, r1 TR1, r2 TR2, r3 TR3, r4 TR4, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, r4, err := retry.f()
		if err == nil {
			return r0, r1, r2, r3, r4, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	var null4 TR4
	return null0, null1, null2, null3, null4, err
}

// Generated Code for Retry function with 0 input(s) and 4 output(s)
type func0to4[TR0 any, TR1 any, TR2 any, TR3 any] func() (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error)
type retry0to4[TR0 any, TR1 any, TR2 any, TR3 any] struct {
	f           func0to4[TR0, TR1, TR2, TR3]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try0to4[TR0 any, TR1 any, TR2 any, TR3 any](f func0to4[TR0, TR1, TR2, TR3]) *retry0to4[TR0, TR1, TR2, TR3] {
	return &retry0to4[TR0, TR1, TR2, TR3]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry0to4[TR0, TR1, TR2, TR3]) ForTimes(times int) *retry0to4[TR0, TR1, TR2, TR3] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry0to4[TR0, TR1, TR2, TR3]) WithBackoff(f BackoffTimingFunc) *retry0to4[TR0, TR1, TR2, TR3] {
	retry.backoff = f
	return retry
}
func (retry retry0to4[TR0, TR1, TR2, TR3]) Run() (r0 TR0, r1 TR1, r2 TR2, r3 TR3, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, r3, err := retry.f()
		if err == nil {
			return r0, r1, r2, r3, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	var null3 TR3
	return null0, null1, null2, null3, err
}

// Generated Code for Retry function with 0 input(s) and 3 output(s)
type func0to3[TR0 any, TR1 any, TR2 any] func() (r0 TR0, r1 TR1, r2 TR2, err error)
type retry0to3[TR0 any, TR1 any, TR2 any] struct {
	f           func0to3[TR0, TR1, TR2]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try0to3[TR0 any, TR1 any, TR2 any](f func0to3[TR0, TR1, TR2]) *retry0to3[TR0, TR1, TR2] {
	return &retry0to3[TR0, TR1, TR2]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry0to3[TR0, TR1, TR2]) ForTimes(times int) *retry0to3[TR0, TR1, TR2] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry0to3[TR0, TR1, TR2]) WithBackoff(f BackoffTimingFunc) *retry0to3[TR0, TR1, TR2] {
	retry.backoff = f
	return retry
}
func (retry retry0to3[TR0, TR1, TR2]) Run() (r0 TR0, r1 TR1, r2 TR2, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, r2, err := retry.f()
		if err == nil {
			return r0, r1, r2, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	var null2 TR2
	return null0, null1, null2, err
}

// Generated Code for Retry function with 0 input(s) and 2 output(s)
type func0to2[TR0 any, TR1 any] func() (r0 TR0, r1 TR1, err error)
type retry0to2[TR0 any, TR1 any] struct {
	f           func0to2[TR0, TR1]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try0to2[TR0 any, TR1 any](f func0to2[TR0, TR1]) *retry0to2[TR0, TR1] {
	return &retry0to2[TR0, TR1]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry0to2[TR0, TR1]) ForTimes(times int) *retry0to2[TR0, TR1] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry0to2[TR0, TR1]) WithBackoff(f BackoffTimingFunc) *retry0to2[TR0, TR1] {
	retry.backoff = f
	return retry
}
func (retry retry0to2[TR0, TR1]) Run() (r0 TR0, r1 TR1, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, r1, err := retry.f()
		if err == nil {
			return r0, r1, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	var null1 TR1
	return null0, null1, err
}

// Generated Code for Retry function with 0 input(s) and 1 output(s)
type func0to1[TR0 any] func() (r0 TR0, err error)
type retry0to1[TR0 any] struct {
	f           func0to1[TR0]
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try0to1[TR0 any](f func0to1[TR0]) *retry0to1[TR0] {
	return &retry0to1[TR0]{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry0to1[TR0]) ForTimes(times int) *retry0to1[TR0] {
	retry.maxAttempts = times
	return retry
}
func (retry *retry0to1[TR0]) WithBackoff(f BackoffTimingFunc) *retry0to1[TR0] {
	retry.backoff = f
	return retry
}
func (retry retry0to1[TR0]) Run() (r0 TR0, err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		r0, err := retry.f()
		if err == nil {
			return r0, nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	var null0 TR0
	return null0, err
}

// Generated Code for Retry function with 0 input(s) and 0 output(s)
type func0to0 func() (err error)
type retry0to0 struct {
	f           func0to0
	backoff     BackoffTimingFunc
	maxAttempts int
}

func Try0to0(f func0to0) *retry0to0 {
	return &retry0to0{
		backoff:     Constant(0),
		f:           f,
		maxAttempts: 0,
	}
}
func (retry *retry0to0) ForTimes(times int) *retry0to0 {
	retry.maxAttempts = times
	return retry
}
func (retry *retry0to0) WithBackoff(f BackoffTimingFunc) *retry0to0 {
	retry.backoff = f
	return retry
}
func (retry retry0to0) Run() (err error) {
	for i := 0; i < retry.maxAttempts; i++ {
		err := retry.f()
		if err == nil {
			return nil
		}
		time.Sleep(retry.backoff(i))
	}
	// get uninitialized instances of return values, aka. null
	return err
}
